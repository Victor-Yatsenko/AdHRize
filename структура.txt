Краткий обзор связей и процессов
HR (браузер)
    ↓ HTTP POST (Flet UI)
Frontend (Docker контейнер с Nginx + Flet)
    ↓ HTTP POST
Backend (Docker контейнер с FastAPI)
    ├─ Получает запрос и валидирует данные
    ├─ Через mongo_client читает структуры отделов/менеджеров/групп из MongoDB
    ├─ Ищет нужный DN и другие параметры
    ├─ Генерирует пароль (password_generator)
    ├─ Через ad_client по WinRM вызывает PowerShell-скрипт на Domain Controller
    ├─ Отправляет уведомление в Teams (teams_notifier)
    ├─ Возвращает результат Frontend
MongoDB (Docker контейнер)
    └─ Хранит JSON-структуры, к которым Backend обращается по запросу
Domain Controller (Windows Server)
    └─ Запускает PowerShell create_user_ad.ps1 с параметрами, создаёт пользователя в AD

Запускает PowerShell
Создают на DC папку, например:
C:\Scripts\AD\
Копируют туда все PowerShell-скрипты (например, create_user_ad.ps1 и вспомогательные).
Убеждаются, что у пользователя (под которым запускается WinRM сессия) есть права чтения и выполнения в этой папке.
Путь в команде PowerShell должен быть полный и точный:
Например:
C:\Scripts\AD\create_user_ad.ps1




/project-root
│
├── client/
│   ├── Dockerfile                               # Сборка образа фронтенда (Flet + Nginx)
│   ├── +- app.py                                   # Flet-приложение — UI для HR с формой
│   ├── requirements.txt                         # Зависимости Python для фронтенда (Flet и пр.)
│   ├── nginx.conf                               # Конфигурация Nginx для отдачи UI и проксирования API запросов
│   └── static/                                  # Статичные файлы (если есть)
│
├── server/
│   ├── Dockerfile                               # Сборка образа бекенда (Python FastAPI + MongoDB клиент + WinRM клиент)
│   ├── app/
│   │   ├── main.py                              # Точка входа FastAPI приложения, роуты API
│   │   ├── models.py                            # Pydantic-модели для валидации данных API
│   │   ├── schemas.py                           # Определение схем запросов/ответов
│   │   ├── config.py                            # Чтение конфигурации из .env
│   │   ├── services/ 
│   │   │   ├── user_service.py                  # Логика создания пользователя (валидация, генерация пароля, подготовка параметров)
│   │   │   ├── ad_client.py                     # Вызов PowerShell на DC через WinRM (авторизация, отправка команд)
│   │   │   ├── mongo_client.py                  # Работа с MongoDB (загрузка/чтение структуры отделов, менеджеров, групп)
│   │   │   ├── teams_notifier.py                # Отправка сообщений в Microsoft Teams через webhook
│   │   │   └── + password_generator.py          # Класс для генерации сложных паролей
│   │   ├── utils/
│   │   │   ├── logger.py                        # Логгирование и обработка ошибок
│   │   │   └── helpers.py                       # Вспомогательные функции (поиск в иерархии и др.)
│   │   └── tests/                               # Юнит- и интеграционные тесты
│   │
│   ├── requirements.txt                         # Python-зависимости (fastapi, pymongo, pywinrm, pydantic и пр.)
│
├── powershell/
│   └── create_user_ad.ps1                       # PowerShell-скрипт на DC для создания пользователя (принимает параметры)
│
├── mongo-init/
│   ├── departments.json                         # Исходные JSON с отделами
│   ├── managers.json                            # JSON с менеджерами
│   └── groups.json                              # JSON с групповыми политиками
│
├── docker-compose.yml                           # Описание сервисов: frontend, backend, mongodb
│
├── .env                                         # Конфигурация и секреты (адреса, логины, пароли, webhook URL и др.)
│
└── docs/
    ├── architecture.md                          # Документация архитектуры
    ├── api_spec.md                              # Описание API Backend
    ├── deployment_guide.md                      # Инструкция по развёртыванию
    └── troubleshooting.md                       # Решение типовых проблем



Держи пример простого конфигурационного провайдера на Python, который умеет читать из .env или из AWS Secrets Manager и по флагу переключается между ними.

import os
from dotenv import load_dotenv
import boto3
from botocore.exceptions import ClientError
import json

class ConfigProvider:
    def __init__(self, use_aws=False, aws_region="us-east-1", aws_secret_name=None):
        self.use_aws = use_aws
        self.aws_region = aws_region
        self.aws_secret_name = aws_secret_name
        self.secrets = {}

        if not self.use_aws:
            load_dotenv()  # Загружаем .env в окружение
            self.secrets = self._load_from_env()
        else:
            if not self.aws_secret_name:
                raise ValueError("AWS secret name must be provided if use_aws=True")
            self.secrets = self._load_from_aws()

    def _load_from_env(self):
        # Считываем нужные переменные из окружения
        return {
            "DB_PASSWORD": os.getenv("DB_PASSWORD"),
            "TEAMS_WEBHOOK_URL": os.getenv("TEAMS_WEBHOOK_URL"),
            "OPEN_PORT": os.getenv("OPEN_PORT"),
            # Добавь сюда другие ключи, которые используешь
        }

    def _load_from_aws(self):
        client = boto3.client('secretsmanager', region_name=self.aws_region)
        try:
            response = client.get_secret_value(SecretId=self.aws_secret_name)
            secret_str = response.get('SecretString')
            if secret_str:
                return json.loads(secret_str)
            else:
                raise ValueError("Empty secret string received from AWS Secrets Manager")
        except ClientError as e:
            print(f"Ошибка получения секрета из AWS: {e}")
            raise

    def get(self, key, default=None):
        return self.secrets.get(key, default)



Использование
# Для локальной разработки
config = ConfigProvider(use_aws=False)

# Для продакшена
# config = ConfigProvider(use_aws=True, aws_region="eu-central-1", aws_secret_name="my_project/prod")

db_password = config.get("DB_PASSWORD")
webhook_url = config.get("TEAMS_WEBHOOK_URL")
port = config.get("OPEN_PORT", 8080)
